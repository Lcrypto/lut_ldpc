/*!
 * \file
 * \brief Program to convert .dat files generated by the PEG program to .alist format
 * \author Michael Meidlinger
 *
 * -------------------------------------------------------------------------
 *
 * Copyright (C) 2017 Michael Meidlinger - All Rights Reserved
 *
 * This file is part of lut_ldpc, a software suite for simulating and designing
 * LDPC decodes based on discrete Lookup Table (LUT) message passing
 *
 * lut_ldpc is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * lut_ldpc distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along
 * with lut_ldpc.  If not, see <http://www.gnu.org/licenses/>.
 *
 * -------------------------------------------------------------------------
 */


#include <itpp/itbase.h>

using namespace itpp;
using namespace std;
int main(int argc, char **argv){
    // Parse file name
    if(argc!=3){
        cout << "Usage: dat2alist infile.dat outfile.alist" << endl;
        return EXIT_FAILURE;
    }
    
    string datfilename(argv[1]);
    string alistfilename(argv[2]);
    
    string line;
    stringstream ss;
    fstream file;
    int N, M, dv_act;
    
    file.open(datfilename.c_str());
    it_assert(file.is_open(),
              "main(): Could not open file \""
              << datfilename << "\" for reading");
    
    // Get Codesize
    getline(file, line);
    ss << line;
    ss >> N;
    it_assert(!ss.fail(), "Cannot read codewordlength N!");
    it_assert(N > 0, "N must be positive!");
    ss.seekg(0, std::ios::end);
    ss.clear();
    // Get Paritysize
    getline(file, line);
    ss << line;
    ss >> M;
    it_assert(!ss.fail(), "Cannot read number of parity constraints M!");
    it_assert(M > 0, "M must be positive!");
    ss.seekg(0, std::ios::end);
    ss.clear();
    // Maximum variable node degree
    getline(file, line);
    ss << line;
    ss >> dv_act;
    it_assert(!ss.fail(), "Cannot read number of parity constraints M!");
    it_assert(dv_act > 0, "dv_act must be positive!");
    ss.seekg(0, std::ios::end);
    ss.clear();
    
    
    GF2mat_sparse H(M,N);
    
    for(int mm=0; mm<M; mm++){
        getline(file, line);
        ss << line;
        for(int dd=0; dd<dv_act; dd++){
            int nn;
            ss >> nn;
            it_assert(!ss.fail(), "Cannot read Element " << dd << " in row "<< mm);
            it_assert(nn >= 0 && nn <= N, "Variable node index out of range!");
            if(nn>0) H.set(mm,nn-1,1);
        }
        ss.seekg(0, std::ios::end);
        ss.clear();
    }
    
    file.close();
    
    GF2mat_sparse_alist Halist;
    
    Halist.from_sparse(H);
    Halist.write(alistfilename);
    
    return EXIT_SUCCESS;
}
